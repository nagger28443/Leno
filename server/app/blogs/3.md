## 概述

本文主要总结在React+React-Router项目中实现离开页面(主要是表单页)时提示用户确认是否确定离开的功能，以避免用户误触导致丢失已填写的数据。

主要分为三种情况:
- 通过路由离开当前页面
- 点击‘返回’等按钮离开当前表单，但仍处在同一路由下
- 刷新或关闭当前页面

## 通过路由离开当前页面

在React-Router v4中，通过在`render`中增加一个`Prompt`组件即可,详见[react-router官方文档](https://reacttraining.com/react-router/core/api/Prompt)。

存在的问题：样式个性化不方便，网上有人提出了方案，但我没有去深究。可见于[这里](https://www.geekjc.com/post/5a950fe9ac7c3a3d745efa60)。


## 点击‘返回’等按钮离开当前表单，但仍处在同一路由下

某些组件设计中，'返回’按钮并不离开当前路由，但是会加载另外的组件，同样会丢失当前表单的数据。由于没有离开当前路由，所以不能通过React-Router的方案阻止用户离开。

不过这一点其实比离开当前路由更简单，可以直接在‘返回’按钮的事件回调中弹出提示，用户确认后再继续函数的执行。

## 刷新或关闭当前页面

这种情况脱离了React-Router所能触及的范畴，但早在React之前就已经有了通用的解决方案，即监听`window.onbeforeunload`事件。同样存在样式不方便自定义的问题，虽然该事件可以返回自定义的提醒消息，但该返回值在chrome中并没有效果。

## 其它

说起来，遇到这个需求的时候第一反应是在`componentWillUnmount`中拦截离开页面的动作，当时只想着使用antd的Modal组件，却误入歧途，拦截不了代码继续执行。原来`window.alert`和`window.confirm`的作用是这样的。每天写React代码，原生API还真是太过生疏了。

不过，这个想法的幼稚之处在于，`window.confirm`虽然暂时拦下了离开当前页面的动作，但是无论用户点击‘确认’还是‘取消’，都无法阻止下一步的路由跳转。:)

## 总结

总的来说，离开确认的功能在实现上并没有什么难度，但样式自定义就不太方便了，随后有时间了可以再回头具体看一下这个问题。


第一篇：文章示例（header）

labels: 前端 markdown

 # h1标题
##  h2标题，（***1和2标题下划线？***，css处理）
  ### h3标题
#### h4标题
##### h5标题
###### h6标题

``int a = 1`code中使用反引号,注意最后空格断开` ``

>这是一段引用,总体思路是尽可能早的加载样式，尽可能晚的加载脚本。原因是脚本执行之前，需要 HTML 和 CSS 解析完成，因此，样式尽可能的往顶部放，当底部脚本开始执行之前，样式有足够的时间完成计算。
>另一端引用,当浏览器发现任何与节点相关的样式时，比如：外部，内部，或行内样式，立即停止渲染 DOM ，并利用这些节点创建 CSSOM。这就是 CSS “渲染阻塞“ 的由来。这里是不同类型样式的优缺点。
>>嵌套引用,当浏览器发现任何与节点相关的样式时，比如：外部，内部，或行内样式，立即停止渲染 DOM ，并利用这些节点创建 CSSOM。这就是 CSS “渲染阻塞“ 的由来。这里是不同类型样式的优缺点。
>>>嵌套引用,当浏览器发现任何与节点相关的样式时，比如：外部，内部，或行内样式，立即停止渲染 DOM ，并利用这些节点创建 CSSOM。这就是 CSS “渲染阻塞“ 的由来。这里是不同类型样式的优缺点。
>>>>嵌套引用,当浏览器发现任何与节点相关的样式时，比如：外部，内部，或行内样式，立即停止渲染 DOM ，并利用这些节点创建 CSSOM。这就是 CSS “渲染阻塞“ 的由来。这里是不同类型样式的优缺点。
>**退出嵌套**,当浏览器发现任何与节点相关的样式时，比如：外部，内部，或行内样式，立即停止渲染 DOM ，并利用这些节点创建 CSSOM。这就是 CSS “渲染阻塞“ 的由来。这里是不同类型样式的优缺点。
>>### **嵌套内的标题**
>这是一段引用,总体思路是尽可能早的加载样式，尽可能晚的加载脚本。原因是脚本执行之前，需要 HTML 和 CSS 解析完成，因此，样式尽可能的往顶部放，当底部脚本开始执行之前，样式有足够的时间完成计算。

- 无序列表,无序列表,无序列表,无序列表,无序列表,无序列表,无序列表,无序列表,无序列表,无序列表,无序列表,无序列表,无序列表,无序列表,无序列表,无序列表,无序列表,无序列表,无序列表,无序列表,
- 无序列表
  - 无序*列表*
- 无序列表
  - 二级列表
    - 三***级列表***
- 无序列表
  1. 有序列表
    2. 有**序列**表
    3. 有序列\n表  999999999999999
    8888
  2. sdf，不依手写需要而定，是数字即可
- 无序列表

段落段落段落段落段落段落**我加粗了哈哈哈哈哈**段落段落段落段落段落段落段落段落段落*我是斜体啊啊啊啊啊啊啊*段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落
段落段落段落段落
   
另一段落另一段落另一段落另一段落另一段，end a line with two or more spaces, and then type return. 生成br 落另一段落另一段落另一段落另一段落另一段落另一段落另一段落另一段落

又一段落，记得空行trim()

- 无序列表
- - 无序列表
  > 嵌套引用段落
- 无序列表
  > 嵌套引用段落,空格开头,两个


    <html>
      <head>
          <title>代码片段，4个空格开头，（tab？s）</title>
      </head>
```
code block
<html>
    <head>
        <title>代码片段，4个空格开头，（tab？s）</title>
    </head>
```

---
***
上面是两条横线

My favorite search engine is [Duck Duck Go](https://duckduckgo.com).

<https://www.markdownguide.org>


<fake@example.com>