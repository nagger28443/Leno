import React from 'react'

export default class sidebar extends React.Component {
  // handle = () => { }
  onWheel = e => {
    console.log(e)
  }
  render() {
    return (
      <aside className={this.props.classNames} style={this.props.style}>
        <h3>sidebar</h3>
        <p>
          I use the vector template in almost all my C++ software. Essentially, you can use it
          whenever you need a dynamic array. The title of my blog post is word play: please use
          vectors, but use them properly if you need speed! R.call 可以用作 R.converge 的
          convergeing
          函数：第一个分支函数生成函数，其余分支函数生成一系列值作为该函数的参数。（R.converge
          第二个参数为一个分支函数列表）。R.call 可以用作 R.converge 的 convergeing
          函数：第一个分支函数生成函数，其余分支函数生成一系列值作为该函数的参数。（R.converge
          第二个参数为一个分支函数列表）。R.call 可以用作 R.converge 的 convergeing
          函数：第一个分支函数生成函数，其余分支函数生成一系列值作为该函数的参数。（R.converge
          第二个参数为一个分支函数列表）。R.call 可以用作 R.converge 的 convergeing
          函数：第一个分支函数生成函数，其余分支函数生成一系列值作为该函数的参数。（R.converge
          第二个参数为一个分支函数列表）。 R.call 可以用作 R.converge 的 convergeing
          函数：第一个分支函数生成函数，其余分支函数生成一系列值作为该函数的参数。（R.converge
          第二个参数为一个分支函数列表）。R.call 可以用作 R.converge 的 convergeing
          函数：第一个分支函数生成函数，其余分支函数生成一系列值作为该函数的参数。（R.converge
          第二个参数为一个分支函数列表）。R.call 可以用作 R.converge 的 convergeing
          函数：第一个分支函数生成函数，其余分支函数生成一系列值作为该函数的参数。（R.converge
          第二个参数为一个分支函数列表）。R.call 可以用作 R.converge 的 convergeing
          函数：第一个分支函数生成函数，其余分支函数生成一系列值作为该函数的参数。（R.converge
          第二个参数为一个分支函数列表）。 R.call 可以用作 R.converge 的 convergeing
          函数：第一个分支函数生成函数，其余分支函数生成一系列值作为该函数的参数。（R.converge
          第二个参数为一个分支函数列表）。R.call 可以用作 R.converge 的 convergeing
          函数：第一个分支函数生成函数，其余分支函数生成一系列值作为该函数的参数。（R.converge
          第二个参数为一个分支函数列表）。R.call 可以用作 R.converge 的 convergeing
          函数：第一个分支函数生成函数，其余分支函数生成一系列值作为该函数的参数。（R.converge
          第二个参数为一个分支函数列表）。R.call 可以用作 R.converge 的 convergeing
          函数：第一个分支函数生成函数，其余分支函数生成一系列值作为该函数的参数。（R.converge
          第二个参数为一个分支函数列表）。
        </p>
      </aside>
    )
  }
}
